
FILE:
	HEADER FILE_ELEMENT*

FILE_ELEMENT:
	IMPORT_STATEMENT      // import ...
	USE_STATEMENT         // use ...
	EXTERNAL_DECLARATION  // (others)

EXTERNAL_DECLARATION:
	STRUCT_DECLARATION    // struct ...
	UNION_DECLARATION     // union ...
	ENUM_DECLARATION      // enum ...
	SYMBOL_DEFINITION     // (others)

STATEMENT:
	STRUCT_DECLARATION    // struct ...
	UNION_DECLARATION     // union ...
	ENUM_DECLARATION      // enum ...
	COMPOUND_STATEMENT    // { ...
	FOR_STATEMENT
	WHILE_STATEMENT
	DO_STATEMENT
	IF_STATEMENT
	SWITCH_STATEMENT
	WHILE_STATEMENT
	BREAK_STATEMENT
	CONTINUE_STATEMENT
	GOTO_STATEMENT
	RETURN_STATEMENT
	;
	EXPRESSION_STATEMENT  // EXPRESSION ;
	LABELED_STATEMENT     // EXPRESSION : ...
	SYMBOL_DEFINITION     // EXPRESSION IDENTIFIER ...
	                      // STORAGE_SPECIFIER ...

EXPRESSION_STATEMENT:
	EXPRESSION ;

LABELED_STATEMENT:
	IDENTIFIER : STATEMENT
	case EXPRESSION : STATEMENT
	default : STATEMENT

SYMBOL_DEFINITION:
	STORAGE_SPECIFIER TYPE IDENTIFIER FUNCTION_OR_VARIABLE_TAIL
	TYPE IDENTIFIER FUNCTION_OR_VARIABLE_TAIL

FUNCTION_OR_VARIABLE_TAIL:
	( PARAMETER_LIST ) FUNCTION_PROPERTIES ;
	( PARAMETER_LIST ) FUNCTION_PROPERTIES COMPOUND_STATEMENT
	;
	= INITIALIZER ;
	= COMPOUND_INITIALIZER ;

TYPE:
	TYPE_MODIFIERS* BASE_TYPE

STORGE_SPECIFIER:
	constant
	typedef
	register
	static
	auto
	restrict

TYPE_MODIFIERS:
	pointer
	array ( ARRAY_SIZE )
	readonly
	volatile

BASE_TYPE:
	NAMESPACED_IDENTIFIER



EXPRESSION:
	ASSIGNMENT_EXPRESSION
	// no comma operator

ASSIGNMENT_EXPRESSION:
	CONDITIONAL_EXPRESSION
	UNARY_EXPRESSION = ASSIGNMENT_EXPRESSION
		*=
		/=
		%=
		+=
		-=
		<<=
		>>=
		&=
		^=
		|=
	// probably doesn't have to be unary, could be 
	// CONDITIONAL_EXPRESSION OPERATOR ASSIGNMENT_EXPRESSION

CONDITIONAL_EXPRESSION:
	LOGICAL_OR_EXPRESSION
	LOGICAL_OR_EXPRESSION ? EXPRESSION : CONDITIONAL_EXPRESSION

LOGICAL_OR_EXPRESSION:
	LOGICAL_AND_EXPRESSION
	LOGICAL_OR_EXPRESSION || LOGICAL_AND_EXPRESSION

LOGICAL_AND_EXPRESSION:
	INCLUSIVE_OR_EXPRESSION
	LOGICAL_AND_EXPRESSION && INCLUSIVE_OR_EXPRESSION

INCLUSIVE_OR_EXPRESSION:
	EXCLUSIVE_OR_EXPRESSION
	INCLUSIVE_OR_EXPRESSION | EXCLUSIVE_OR_EXPRESSION

EXCLUSIVE_OR_EXPRESSION:
	AND_EXPRESSION
	EXCLUSIVE_OR_EXPRESSION ^ AND_EXPRESSION

AND_EXPRESSION:
	EQUALITY_EXPRESSION
	AND_EXPRESSION & EQUALITY_EXPRESSION

EQUALITY_EXPRESSION:
	RELATIONAL_EXPRESSION
	EQUALITY_EXPRESSION == RELATIONAL_EXPRESSION
		!=

RELATIONAL_EXPRESSION:
	SHIFT_EXPRESSION
	RELATIONAL_EXPRESSION < SHIFT_EXPRESSION
		>
		<=
		>=

SHIFT_EXPRESSION:
	ADDITIVE_EXPRESSION
	SHIFT_EXPRESSION << ADDITIVE_EXPRESSION
		>>

ADDITIVE_EXPRESSION:
	MULTIPLICATIVE_EXPRESSION
	ADDITIVE_EXPRESSION + MULTIPLICATIVE_EXPRESSION
		-

MULTIPLICATIVE_EXPRESSION:
	UNARY_EXPRESSION
	MULTIPLICATIVE_EXPRESSION * UNARY_EXPRESSION
		/
		%
	//no cast expression, casts look like function calls now

UNARY_EXPRESSION:
	POSTFIX_EXPRESSION
	sizeof UNARY_EXPRESSION
	++ UNARY_EXPRESSION
		--
		&
		*
		+
		-
		~
		!

POSTFIX_EXPRESSION:
	PRIMARY_EXPRESSION
	POSTFIX_EXPRESSION [ EXPRESSION_LIST ]
	POSTFIX_EXPRESSION ( EXPRESSION_LIST )
	POSTFIX_EXPRESSION { INITIALIZER_LIST }
	POSTFIX_EXPRESSION . IDENTIFIER // ambiguous with NAMESPACE_EXPRESSION
	POSTFIX_EXPRESSION ++
	POSTFIX_EXPRESSION --
	// no arrow operator POSTFIX_EXPRESSION -> IDENTIFIER

PRIMARY_EXPRESSION:
	TYPE_EXPRESSION
	LITERAL_VALUE
	( EXPRESSION )

TYPE_EXPRESSION:
	NAMESPACE_EXPRESSION
	TYPE_MODIFIER TYPE_EXPRESSION

NAMESPACE_EXPRESSION:
	IDENTIFIER
	NAMESPACE_EXPRESSION . IDENTIFIER // ambiguous with POSTFIX_EXPRESSION
	// ambiguity resolution:
	// Conflict is between the namespace selection dot and
	// the struct member dot.
	// They can be treated as equivalent in non-type expressions.
	// For types, the namespace dot needs to have higher precedence than
	// the TYPE_MODIFIER operators, but a type can never have a 
	// struct member, so for types all dots are namespace dots.
	// So it works to do a greedy parse whenre the namespace expression
	// always claims as many dots as possible.
	// (as long as the later compiler stages don't care about the
	// difference between a dot operator in a NAMESPACE_EXPRESSION node
	// and the dot operator in a POSTFIX_EXPRESSION node)

