
FILE:
	HEADER EOF
	HEADER FILE_CONTENT EOF

HEADER:
	janus VERSION ;
	janus VERSION { HEADER_OPTIONS }

HEADER_OPTIONS:
	ASSIGNMENT_EXPRESSION ;
	ASSIGNMENT_EXPRESSION ; HEADER_OPTIONS

FILE_CONTENT:
	FILE_DECLARATION
	FILE_DECLARATION FILE_CONTENT

FILE_DECLARATION:
	IMPORT
	DEF
	STRUCT
	INTERFACE
	METHOD
	OPERATOR_DEF

IMPORT:
	import IMPORT_NAME;
	import IMPORT_NAME as IMPORT_NAME;

DEF:
	def TOKEN FUNCTION_TYPE { FUNCTION_CONTENT }
	def TOKEN TYPE = { BLOCK_CONTENT } ;
	def TOKEN TYPE = [ LIST_CONTENT ] ;
	def TOKEN TYPE = { } ;
	def TOKEN TYPE = [ ] ;
	def TOKEN TYPE = EXPRESSION ;
	def TOKEN FUNCTION_TYPE ;
	def TOKEN TYPE ;
	def TOKEN = { BLOCK_CONTENT } ;
	def TOKEN = [ LIST_CONTENT ] ;
	def TOKEN = EXPRESION ;

STRUCT:
	struct TYPE_NAME { STRUCT_CONTENT }
	struct TYPE_NAME ;
	m_struct TYPE_NAME { STRUCT_CONTENT }
	m_struct TYPE_NAME ;

INTERFACE:
	interface TYPE_NAME { INTERFACE_CONTENT }
	interface TYPE_NAME extends EXTENDS_LIST { INTERFACE_CONTENT }

TYPE_NAME:
	TOKEN
	TOKEN ( PARAMETER_LIST )
	# FIXME not a full parameter list, only named CTypes and constants

TYPE:
	TOKEN
	TOKEN ( TYPE_LIST )
	m_array(TYPE, INTEGER_CONSTANT)
	m_slice(TYPE)
	m_ref(TYPE)
	array(TYPE)
	ref(TYPE)
	function ( PARAMETER_LIST ) -> TYPE
	# FIXME some contexts allow > TYPE to indicate automatic conversion
	# FIXME Module.Type(params) hast to work


PARAMETER_LIST:
	comma separated list of
	TOKEN TYPE
	TOKEN > TYPE


STRUCT_CONTENT:
	sequence of
	def TOKEN TYPE ;
	def TOKEN TYPE { FUNCTION_CONTENT }
	implements TOKEN ;
	implements TOKEN { IMPLEMENTS_CONTENT }

FUNCTION_CONTENT:
	sequence of
	DEF       # do we allow nested function definitions?
	while EXPRESSION { FUNCTION_CONTENT }
	if EXPRESSION { FUNCTION_CONTENT }
	if EXPRESSION { FUNCTION_CONTENT } ELSE
	for TOKEN in EXPRESSION { FUNCTION_CONTENT }
	return EXPRESSION ;
	return ;
	ASSIGNMENT_EXPRESSION ;
	EXPRESSION ;
	;

ELSE:
	else { FUNCTION_CONTENT }
	else if { FUNCTION_CONTENT }
	else if { FUNCTION_CONTENT } ELSE

LIST_CONTENT:
	EXPRESSION
	EXPRESSION , LIST_CONTENT
	# FIXME can end with a comma
	# FIXME consider  allowing either comma or semicolon as separator

BLOCK_CONTENT:
	list of
	EXPRESSION = EXPRESSION
	# FIXME can end with a comma

INTERFACE_CONTENT:
	sequence of
	def TOKEN TYPE ;

METHOD:
	method TYPE . TOKEN TYPE ;
	method TYPE . TOKEN TYPE { FUNCTION_CONTENT }

OPERATOR_DEF:
	operator OPERATOR TYPE ;
	operator OPERATOR TYPE { FUNCTION_CONTENT }

ASSIGNMENT_EXPRESSION:
	EXPRESSION = EXPRESSION
	EXPRESSION ASSIGN_OP EXPRESSION   #  +=  -=  *=  /=
	EXPRESSION POSTINCREMENT_OP       # ++  --

EXPRESSION:
	EXPRESSION_AND
	EXPRESSION OR_OP EXPRESSION_AND   # |  ^|

EXPRESSION_AND:
	EXPRESSION_COMPARE
	EXPRESSION_AND AND_OP EXPRESSION_COMPARE   #  &

EXPRESSION_COMPARE:
	EXPRESSION_ADD
	EXPRESSION_COMPARE COMPARE_OP EXPRESSION_ADD  # == != ~~ !~ <= >=

EXPRESSION_ADD:
	EXPRESSION_MULT
	EXPRESSION_ADD ADD_OP EXPRESSION_MULT  #  + -

EXPRESSION_MULT:
	EXPRESSION_EXP
	EXPRESSION_MULT MULT_OP EXPRESSION_EXP # * /  // +/ -/ %% +% -% << >>

EXPRESSION_EXP:
	EXPRESSION_PREFIX
	EXPRESSION_EXP EXP_OP EXPRESSION_PREFIX  # ^

EXPRESSION_PREFIX:
	EXPRESSION_SUFFIX
	PREFIX_OP EXPRESSION_PREFIX   # !

EXPRESSION_SUFFIX:
	( EXPRESSION )
	EXPRESSION_DOT
	NUMBER
	STRING
	CHARACTER
	EXPRESSION_SUFFIX SUFFIX_OP
	EXPRESSION_SUFFIX [ EXPRESSION ]
	EXPRESSION_SUFFIX ( EXPRESSION_LIST )

EXPRESSION_DOT:
	SYMBOL
	EXPRESSION_DOT . SYMBOL

EXPRESSION_LIST:
	EXPRESSION
	EXPRESSION_LIST , EXPRESSION

# FIXME expression operator precedence
# Dot for scope resolution and object dereference
# parentheses
# suffix operators and array derefs
# prefix operators
# exponents  ^
# multiply  * // / %%   << >>
# add + -
# comparison  ==  !=  !~  ~~ ...
# logical and   &
# logical or  | ^|



